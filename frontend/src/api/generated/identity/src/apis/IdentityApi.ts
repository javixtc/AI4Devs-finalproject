// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * Meditation Builder - Identity API
 * API for Google OAuth login, session management and protected-resource access control.  Bounded Context: **Identity** (new BC — US1)  Core capabilities derived from BDD When steps: - **C1/C2** – Authenticate with Google credential and get own session token (upsert: creates profile on first access, recovers it on subsequent accesses) - **C3** – Protected resources respond 401 when no valid session token is present (enforced by security filter, documented here for contract completeness) - **C4** – Invalidate the active session (logout)  > C5 (cancel Google authorization screen) is handled exclusively on the frontend; it generates no backend capability.  Architecture: Hexagonal (Ports & Adapters), BDD-First, API-First Bounded Context: `com.hexagonal.identity`  Authentication flow: 1. Frontend obtains Google `id_token` via `@react-oauth/google` 2. Frontend POSTs `id_token` to `POST /identity/auth/google` 3. Backend validates `id_token` against Google JWKS, upserts `PerfilDeUsuario`, issues own JWT 4. Frontend stores JWT in memory (Zustand); sends it as `Authorization: Bearer <jwt>` on every request 5. All other BC endpoints require valid Bearer JWT via the shared security filter 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AuthResponse,
  ErrorResponse,
  GoogleAuthRequest,
} from '../models/index';
import {
    AuthResponseFromJSON,
    AuthResponseToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    GoogleAuthRequestFromJSON,
    GoogleAuthRequestToJSON,
} from '../models/index';

export interface AuthenticateWithGoogleRequest {
    googleAuthRequest: GoogleAuthRequest;
}

/**
 * 
 */
export class IdentityApi extends runtime.BaseAPI {

    /**
     * Validates the Google `id_token` received from the frontend and: - **First access** (C1): creates a `PerfilDeUsuario` with a new UUID and returns the session token + profile data. - **Subsequent access** (C2): recovers the existing `PerfilDeUsuario` and returns a fresh session token + profile data.  The returned `sessionToken` is a signed JWT issued by this backend (not a Google token). It must be sent as `Authorization: Bearer <sessionToken>` in all subsequent requests.  Maps to BDD scenarios: - \"Primer acceso de un usuario nuevo con su cuenta de Gmail\" - \"Acceso recurrente de un usuario ya registrado\" 
     * Authenticate with Google credential and obtain session token
     */
    async authenticateWithGoogleRaw(requestParameters: AuthenticateWithGoogleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthResponse>> {
        if (requestParameters['googleAuthRequest'] == null) {
            throw new runtime.RequiredError(
                'googleAuthRequest',
                'Required parameter "googleAuthRequest" was null or undefined when calling authenticateWithGoogle().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/identity/auth/google`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GoogleAuthRequestToJSON(requestParameters['googleAuthRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthResponseFromJSON(jsonValue));
    }

    /**
     * Validates the Google `id_token` received from the frontend and: - **First access** (C1): creates a `PerfilDeUsuario` with a new UUID and returns the session token + profile data. - **Subsequent access** (C2): recovers the existing `PerfilDeUsuario` and returns a fresh session token + profile data.  The returned `sessionToken` is a signed JWT issued by this backend (not a Google token). It must be sent as `Authorization: Bearer <sessionToken>` in all subsequent requests.  Maps to BDD scenarios: - \"Primer acceso de un usuario nuevo con su cuenta de Gmail\" - \"Acceso recurrente de un usuario ya registrado\" 
     * Authenticate with Google credential and obtain session token
     */
    async authenticateWithGoogle(requestParameters: AuthenticateWithGoogleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthResponse> {
        const response = await this.authenticateWithGoogleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Invalidates the current session. After this call, the `sessionToken` sent in the Authorization header is no longer accepted by the security filter.  Maps to BDD scenario: - \"Cierre de sesion\" 
     * Invalidate the active session
     */
    async logoutRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/identity/auth/logout`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Invalidates the current session. After this call, the `sessionToken` sent in the Authorization header is no longer accepted by the security filter.  Maps to BDD scenario: - \"Cierre de sesion\" 
     * Invalidate the active session
     */
    async logout(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.logoutRaw(initOverrides);
    }

}
